{% set grid_size = theme_var('grid-size') %}

<script src="/user/themes/quark/js/bricklayer.min.js"></script>
<script src="/user/themes/quark/js/scopedQuerySelectorShim.min.js"></script>
<link href="/user/themes/quark/css/bricklayer.css" type="text/css" rel="stylesheet">
<link href="/user/themes/myquark/css/reviews-custom.css" type="text/css" rel="stylesheet">

<section class="section modular-text {{ page.header.class}}">
  <section class="container {{ grid_size }}">

    {{ page.content | raw }}

    {# --- filtering & limits --------------------------------------------- #}
    {% set tags_to_filter = header_var('review-tags') | defined([]) %}
    {% set limit = header_var('limit') | defined(10) | int %}

    {# Build full filtered collection, then slice first batch #}
    {% set all = taxonomy.findTaxonomy({'category': 'review'}) %}
    {% if tags_to_filter|length > 0 %}
      {% set all = all
        | filter(p => (p.taxonomy()['review-tag'] ?? []) | filter(t => t in tags_to_filter) | length > 0)
      %}
    {% endif %}
    {% set all = all | sort | reverse %}
    {% set total_count = all|length %}
    {% set initial = all | slice(0, limit) %}

    <div class="bricklayer" id="testimonial-wall">
      {% for review in initial %}
        {% include 'partials/review-card.html.twig' with { review: review } %}
      {% endfor %}
    </div>

    {% if total_count > limit %}
      <div class="text-center mt-2">
        <button id="reviews-load-more"
                class="btn"
                data-limit="{{ limit }}"
                data-offset="{{ limit }}"
                data-tags="{{ tags_to_filter|join(',')|e('html_attr') }}">
          Load more
        </button>
        <div id="reviews-loader" class="loading" style="display:none;"></div>
      </div>
    {% endif %}

  </section>
</section>

<script>
(function () {
  var wall   = document.getElementById('testimonial-wall');
  var btn    = document.getElementById('reviews-load-more');
  var loader = document.getElementById('reviews-loader');

  // Init Bricklayer
  var bricklayer = new Bricklayer(wall);

  if (!btn) return;

  var API_URL = 'https://mathspp.com/api/testimonials.json';

  function buildUrl(limit, offset, tagsCSV) {
    var url = new URL(API_URL);
    url.searchParams.set('limit', String(limit));
    url.searchParams.set('offset', String(offset));
    if (tagsCSV && tagsCSV.trim() !== '') {
      url.searchParams.set('review-tag', tagsCSV);
    }
    return url.toString();
  }

  function htmlStringToNode(html) {
    var tpl = document.createElement('template');
    tpl.innerHTML = html.trim();
    return tpl.content.firstElementChild;
  }

  function getColumns() {
    return wall.querySelectorAll('.bricklayer-column');
  }

  function shortestColumn(columns) {
    var minCol = null;
    var minH = Infinity;
    (columns.forEach ? columns : Array.prototype.slice.call(columns)).forEach(function (col) {
      var h = col.getBoundingClientRect().height;
      if (h < minH) { minH = h; minCol = col; }
    });
    return minCol || wall; // fallback pre-init
  }

  // Append a single card respecting Bricklayer's columns
  function appendCard(node) {
    if (bricklayer && typeof bricklayer.append === 'function') {
      bricklayer.append(node);
      return;
    }
    var cols = getColumns();
    if (cols.length) {
      shortestColumn(cols).appendChild(node);
    } else {
      wall.appendChild(node);
    }
  }

  // Wait for images inside a container/fragment, then cb
  function onImagesLoad(el, cb) {
    var imgs = el.querySelectorAll ? el.querySelectorAll('img') : [];
    if (!imgs.length) { cb(); return; }
    var remaining = imgs.length;
    (imgs.forEach ? imgs : Array.prototype.slice.call(imgs)).forEach(function (img) {
      if (img.complete) { if (--remaining === 0) cb(); }
      else {
        img.addEventListener('load',  function () { if (--remaining === 0) cb(); });
        img.addEventListener('error', function () { if (--remaining === 0) cb(); });
      }
    });
  }

  // Keep the button anchored visually across layout changes
  function withScrollAnchor(anchorEl, work) {
    var beforeTop = anchorEl.getBoundingClientRect().top;
    work(function done() {
      // wait for layout to settle (one or two frames)
      requestAnimationFrame(function () {
        requestAnimationFrame(function () {
          var afterTop = anchorEl.getBoundingClientRect().top;
          var delta = afterTop - beforeTop;
          if (delta !== 0) {
            window.scrollBy(0, delta);
          }
        });
      });
    });
  }

  btn.addEventListener('click', async function (ev) {
    ev.preventDefault();

    var limit  = parseInt(btn.dataset.limit || '10', 10);
    var offset = parseInt(btn.dataset.offset || '0', 10);
    var tags   = btn.dataset.tags || '';

    // show a tiny loader without shifting layout (avoid jumps)
    btn.disabled = true;
    if (loader) loader.style.visibility = 'visible';

    try {
      const res = await fetch(buildUrl(limit, offset, tags), {
        headers: { 'Accept': 'application/json' },
        credentials: 'same-origin'
      });
      if (!res.ok) throw new Error('Failed to load more testimonials');
      const data = await res.json();

      var fragment = document.createDocumentFragment();
      var appendedCount = 0;

      if (Array.isArray(data.items)) {
        data.items.forEach(function (html) {
          var node = htmlStringToNode(html);
          if (node) {
            fragment.appendChild(node);
            appendedCount += 1;
          }
        });
      }

      // Anchor scroll at the button while we mutate & reflow
      withScrollAnchor(btn, function (done) {
        onImagesLoad(fragment, function () {
          // Move children out of fragment and into columns one by one
          while (fragment.firstChild) {
            appendCard(fragment.firstChild);
          }
          // Ask Bricklayer to reflow if possible
          if (bricklayer && typeof bricklayer.redraw === 'function') {
            bricklayer.redraw();
          }
          done();
        });
      });

      // Update offset
      btn.dataset.offset = String(offset + (data.count || appendedCount));

      // Hide button if no more
      if (!data.has_more || (data.count || appendedCount) === 0) {
        btn.style.display = 'none';
      }
    } catch (err) {
      console.error(err);
      btn.textContent = 'Try again';
      btn.disabled = false;
    } finally {
      if (loader) loader.style.visibility = 'hidden';
      if (btn && btn.style.display !== 'none') btn.disabled = false;
    }
  });
})();
</script>
